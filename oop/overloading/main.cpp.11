#include <iostream>
#include <vector>
using namespace std;

// Consider an actual class
class Obj {
  static int i, j;

public:
  void f() const { cout << i++ << endl; }
  void g() const { cout << j++ << endl; }
};

// static member definitions
int Obj::i = 10;
int Obj::j = 12;

// implement a container for the above class
class ObjContainer {
  vector<Obj *> a;

public:
  void add(Obj *obj) {
    a.push_back(obj); // call vector's standard method
  }
  friend class SmartPointer;
};

// implement smart pointer to access member of Obj class
class SmartPointer {
  ObjContainer oc;
  int index;

public:
  SmartPointer(ObjContainer &objc) {
    oc = objc;
    index = 0;
  }

  // return value indicates end of list
  bool operator++() {
    // prefix version
    if (index >= oc.a.size())
      return false;
    if (oc.a[++index] == 0)
      return false;
    return true;
  }

  bool operator++(int) {
    // postfix version
    return operator++();
  }

  // overload operator->
  //The (second) const specifier ensures that calling the method will not modify the instance members. Because the each of the member method has an implicit input pointer this, the const specifier can also be understood as making the input pointer this from a pointer into a pointer to const object.
  //For example,
  //const T* data() const
  //the input pointer Vector* this will become Vector const* this if the member method has const specifier
  Obj *operator->() const {
    if (!oc.a[index]) {
      cout << "Zero value";
      return (Obj *)0;
    }
    return oc.a[index];
  }
};

int main() {
  const int sz = 10;
  Obj o[sz];
  ObjContainer oc;

  for (int i = 0; i < sz; i++) {
    oc.add(&o[i]);
  }

  SmartPointer sp(oc); // create an iterator
  do {
    sp->f(); // smart pointer call
    sp->g();
  } while (sp++);
}