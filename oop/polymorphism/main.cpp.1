#include <iostream>
using namespace std;

class Shape {
protected:
  int width, height;

public:
  Shape(int a = 0, int b = 0) {
    width = a;
    height = b;
  }

  /*
  Without volatile, result will be:
  Parent class area :70
  Parent class area :50
  The reason for the incorrect output is that the call of the function area() is
  being set once by the compiler as the version defined in the base class. This
  is called static resolution of the function call, or static linkage - the
  function call is fixed before the program is executed. This is also sometimes
  called early binding because the area() function is set during the compilation
  of the program.

  With volatile, result will be:
  Rectangle class area :70
  Triangle class area :25

  which is expected
  */
  int area() {
    cout << "Parent class area :" << width * height << endl;
    return width * height;
  }
};

class Rectangle : public Shape {
public:
  Rectangle(int a = 0, int b = 0) : Shape(a, b) {}

  int area() {
    cout << "Rectangle class area :" << width * height << endl;
    return width * height;
  }
};

class Triangle : public Shape {
public:
  Triangle(int a = 0, int b = 0) : Shape(a, b) {}

  int area() {
    cout << "Triangle class area :" << (width * height) / 2 << endl;
    return (width * height) / 2;
  }
};

int main() {
  Shape *shape;
  Rectangle rec(10, 7);
  Triangle tri(10, 5);

  // store the address of Rectangle
  shape = &rec;

  // call rectangle area
  shape->area();

  // store the address of Triangle
  shape = &tri;

  // call triangle area
  shape->area();
}